---
title: "Tidbits of managing configuration with env-schema for Node.js apps"
description: >-
  Level up your Node.js apps with env-schema! Manage configurations effortlessly and learn useful practices for building for configuration management.
date: '2023-08-03'
pubDate: '2023-08-03'
categories: []
keywords: []
draft: true
tags: ["env-schema", "nodejs", "configuration", "backend", "javascript"]
slug: 
image: ~/assets/images/blog/photo-1682268294570-616e9ca9791b.jpg
---

# Tidbits of managing configuration with env-schema for Node.js apps

As Node.js developers, we often find ourselves dealing with various configuration options to tailor our applications for different environments. Configuration management is a critical aspect of building backend servers, allowing us to control the behavior of our applications without modifying the codebase, such as defining database configuration and other parameters.

In this blog post, we will explore the [env-schema](https://github.com/fastify/env-schema) npm package, an open-source library, part of the Fastify maintainers team, that simplifies configuration management in Node.js apps.

Whether you are a seasoned developer or just starting your Node.js journey, understanding how to manage configurations efficiently is essential for building scalable and maintainable applications.

## Introducing env-schema

The `env-schema` npm package offers a straightforward yet effective solution for handling configuration data in Node.js applications. It enables us to define a schema for our environment variables, ensuring that the required variables are present and have the correct data types. By validating and loading the configuration data, `env-schema` helps us avoid runtime errors and ensures our application starts with a valid configuration.

To get started, we need to install the package via npm:

```sh
npm install env-schema
```

Now, let's dive into a code example that demonstrates how to use `env-schema` in a Node.js application with a schema defining essential configuration variables.

```javascript
// config.js
const envSchema = require('env-schema');

const schema = {
  type: 'object',
  required: ['PORT', 'DB_USER', 'DB_PASS', 'DB_HOST', 'DB_PORT', 'DB_NAME'],
  properties: {
    PORT: {
      type: 'integer',
      default: 3000,
    },
    DB_USER: {
      type: 'string',
    },
    DB_PASS: {
      type: 'string',
    },
    DB_HOST: {
      type: 'string',
      default: 'localhost',
    },
    DB_PORT: {
      type: 'integer',
      default: 5432,
    },
    DB_NAME: {
      type: 'string',
    },
  },
};

const config = envSchema({ schema });

console.log('Configuration:', config);
```

In this example, we define a schema object containing the required environment variables (`PORT`, `DB_USER`, `DB_PASS`, `DB_HOST`, `DB_PORT`, and `DB_NAME`). Additionally, we provide default values for some variables to ensure our application works even if they are not explicitly set in the environment.

> WARNING: in a production environment you shouldn't log the configuration due to privacy and security concerns. The use of `console.log` in the above code snippet is just an example for demonstration purposes.

When you run the application, `env-schema` will validate the environment variables based on the schema. If any required variables are missing or have incorrect types, it will throw an error with meaningful messages indicating which variables failed validation.

## Tidbits of useful practices with env-schema

Now that we have a basic understanding of how to use `env-schema`, let's explore other useful practices for managing configuration in Node.js apps.

### Data loading precedence in env-schema

One essential aspect of configuration management is determining the order of precedence for loading data from different sources. With `env-schema`, the order of precedence is as follows, from least significant to most:

1. Data sourced from a `.env` file (when dotenv configuration option is set).
2. Data sourced from environment variables in `process.env`.
3. Data provided via the `data` configuration option.

As such, any configuration parameters provided via the `data` option will always take precedence and override any other values from either the `.env` file and process's environment variables.

By understanding this precedence, we can ensure that our application's configurations are correctly loaded.

### Supporting dual-parameters for the same configuration

In some scenarios, you may encounter applications that offer multiple ways to configure the same functionality. For example, instead of specifying individual database configuration variables (`DB_USER`, `DB_PASS`, `DB_HOST`, etc.), you might have a single variable called `DATABASE_URL` that contains all the necessary information. This approach is common, especially in platforms like Heroku.

To support both methods of configuration, we can use the `anyOf` schema declaration as part of our required fields. Let's modify our previous schema to accommodate the `DATABASE_URL` option:

```javascript
const schema = {
  type: 'object',
  required: ['PORT', 'HOST'],
  anyOf: [
    {
      required: ['DB_HOST', 'DB_PORT', 'DB_USER', 'DB_PASSWORD', 'DB_NAME'],
    },
    {
      required: ['DATABASE_URL'],
    },
  ],
};
```

With this updated schema, either specifying individual database variables or providing a `DATABASE_URL` will be considered valid, making your application more flexible in different environments.

## Conclusion

The `env-schema` npm package offers a fantastic solution for managing configuration in Node.js applications. By defining a schema for your environment variables, you can ensure that the correct configurations are in place for your app to run smoothly. Its validation and data loading precedence features give you confidence that your application starts with a valid and consistent configuration.

Happy coding and may your Node.js apps thrive with the power of env-schema!
