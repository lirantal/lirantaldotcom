---
title: "Configuration patterns for Node.js applications"
description: >-
  Every Node.js application needs configuration management, but there are many ways to do it. You might have heard about `.env` files, and packages like dotenv, convict, env-schema so let's explore the different configuration patterns and how to use them.
date: '2023-09-08'
pubDate: '2023-09-08'
categories: []
keywords: []
draft: true
tags: ["config", "dotenv", ".env", "nodejs"]
slug: 
image: ~/assets/images/blog/
---

Crafting robust and maintainable applications is no small feat. One of the fundamental pillars of building reliable Node.js applications is effective configuration management.

Configuration encompasses a wide array of parameters, from database connection details to API keys, and even application-specific settings. Regardless of the size or complexity of your Node.js project, you'll inevitably encounter the challenge of handling configuration data.

In this blog post, we're going to delve deep into the world of configuration patterns for Node.js applications. We'll explore the various strategies and tools at your disposal to efficiently manage configuration data. Whether you're a seasoned Node.js developer looking to refine your practices or a newcomer eager to learn, this post will equip you with the knowledge you need to make informed decisions regarding your application's configuration.

## Why managing configuration for Node.js application is crucial?

Before we dive into the intricacies of different configuration patterns, let's take a moment to understand why configuration management is so crucial in Node.js applications.

Imagine building a Node.js application without a clear and organized way to handle configuration. You'd likely end up hardcoding sensitive information like API keys directly into your codebase (oh no! ðŸ˜³), scattering configuration values throughout your application files (maintainability is ðŸ˜­), and making it nearly impossible to adapt to different environments seamlessly.

### Pillars of effective and robust configuration management:

- Doesn't impede security: Storing sensitive information like database credentials and API keys securely is paramount. Without proper configuration practices, your application could be susceptible to data breaches.

- Promotes deployment portability: Your application should run consistently across various environments, such as development, testing, and production. Good patterns of configuration management do not couple your environments to your application or to your configuration. Instead, it allows your application to transparently and seamlessly deploy to different environments, unaware of the differences between them.

- Simplifies maintenance: As your application evolves, so do its configuration requirements. Having a robust configuration management system in place makes it easier to make changes and updates without rewriting large sections of code or accessing ad-hoc configuration files or environment variables.

## How to load configuration in Node.js applications?

Now that we've highlighted the importance of configuration management, let's embark on our journey through the various configuration patterns available for Node.js applications.

You might have heard about some common approaches like using `.env` files or popular packages like [dotenv](https://snyk.io/advisor/npm-package/dotenv), [convict](https://snyk.io/advisor/npm-package/convict), and [env-schema](https://snyk.io/advisor/npm-package/env-schema). We'll explore these options in detail.

The following depicts, very shallowly, the possible ways to load configuration in Node.js applications, ordered from the least effective to the most robust configuration management pattern:

1. A `config.json` file
2. Environment variables
3. Typed configuration 
4. Validated configuration





## Concerns with `.env` files:

### They are not type safe

### They are not validated

### They perpetuate configuration drift

`.env` files are most often not versioned via Git, so that secrets are not leaked. But this means that the configuration is not versioned either, and it's hard to know what configuration was used for a given deployment.

Developers will also be concerned that because `.env` files aren't committed to the Git repository, then new configuration options aren't easily discoverable. This can lead to configuration drift, where different environments have different configuration options.

## Node.js configuration anti-patterns

What are some common anti-patterns or practices that you should avoid when handling configuration in Node.js applications?

These anti-patterns may seem tempting at times but can lead to maintenance nightmares, security vulnerabilities, and overall codebase chaos.

### Hardcoding configuration data

One of the most prevalent anti-patterns is hardcoding configuration data directly into your source code.

It sounds so naive that you might be wondering why anyone would ever do this, but more often than not, it's a common "quick fix" that developers resort to when they're in a hurry.

While hardcoding configuration data may appear convenient for quick development, it has several downsides ranging from security risks of exposing sensitive information in the codebase to inflexibility and poor maintainability.

Node.js configuration anti-pattern to avoid, demonstrating hardcoded configuration data in the codebase:

```js
const express = require('express');
const mongoose = require('mongoose');

const app = express();

// Anti-Pattern: Hardcoded configuration data
const dbUsername = 'your_db_username';
const dbPassword = 'your_db_password';
const dbHost = 'localhost';
const dbPort = '27017';
const dbName = 'your_database_name';

// Establish a database connection
mongoose.connect(`mongodb://${dbUsername}:${dbPassword}@${dbHost}:${dbPort}/${dbName}`, {
  useNewUrlParser: true,
  useUnifiedTopology: true,
});

const db = mongoose.connection;

app.get('/', (req, res) => {
  res.send('Hello World');
});

// Anti-Pattern: Hardcoded configuration data
app.listen(3000, () => {
  console.log(`Server is running on port ${3000}`);
});
```

In this code, the database credentials (i.e., `dbPassword`) are hardcoded directly into the codebase. The HTTP web server port of `3000` is also hardcoded.

### Scattered configuration data

Another common pitfall is scattering configuration data across multiple files or modules within your application.

This haphazard approach can result in maintenance nightmares as you hunt down which part of your application is responsible for a particular configuration. It also makes it difficult to update configuration values when they're spread across different parts of your codebase.

To add insult to injury, inconsistencies may arise when different parts of your application use different values for the same configuration parameter. Also, good luck debugging!

<div class="flex items-center justify-center">
<blockquote class="twitter-tweet"><p lang="en" dir="ltr">Spreading env variable usage across all your source files (or dependencies) is a recipe for an unmaintainable codebase.</p>&mdash; Matteo Collina (@matteocollina) <a href="https://twitter.com/matteocollina/status/1691843497890861402?ref_src=twsrc%5Etfw">August 16, 2023</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
</div>

Node.js configuration anti-pattern to avoid, demonstrating scattered configuration data across multiple files:

```js
// 
// FILE: server.js
// 
const express = require('express');
const app = express();

// Anti-Pattern: Scattered configuration data
const port = 3000;

app.listen(port, () => {
  console.log(`Server is running on port ${port}`);
});
```

```js
//
// FILE: database.js
// 
const mongoose = require('mongoose');

// Anti-Pattern: Scattered configuration data
const dbUsername = 'your_db_username';
const dbPassword = 'your_db_password';
const dbHost = 'localhost';
const dbPort = '27017';
const dbName = 'your_database_name';

mongoose.connect(`mongodb://${dbUsername}:${dbPassword}@${dbHost}:${dbPort}/${dbName}`, {
  useNewUrlParser: true,
  useUnifiedTopology: true,
});
```

```js
//
// FILE: routes.js
//
const express = require('express');
const router = express.Router();

// Anti-Pattern: Scattered configuration data
const apiBaseUrl = process.env.API_BASE_URL;
const apiToken = process.env.API_TOKEN;

router.get('/data', (req, res) => {
  // Make a request to an external API using the scattered configuration data
  // ...
});

module.exports = router;
```

You'll notice that a variation of this anti-pattern is when scattered configuration data is accessed via environment variables such as `process.env.API_BASE_URL` through-out the codebase.

While environment variables are a viable option for configuration management, they can quickly become unwieldy when used in this manner.

### Environment-dependent configurations

Manually switching between different configuration settings based on the environment (e.g., development, staging, production) is another anti-pattern. This involves writing conditional code blocks to handle different settings, which can lead to:

- Human error: Mistakes can happen, and you might forget to switch the environment, potentially leading to data corruption or other issues.

- Code complexity: Your codebase can quickly become cluttered with environment-specific logic, making it harder to understand and maintain.

Node.js configuration anti-pattern to avoid, demonstrating environment-dependent configurations

```js
const express = require('express');
const app = express();

let dbUrl;

// Anti-Pattern: Environment-dependent configurations
if (process.env.NODE_ENV === 'development') {
  dbUrl = 'mongodb://localhost:27017/dev_database';
} else if (process.env.NODE_ENV === 'production') {
  dbUrl = 'mongodb://dbserver.prod:27017/prod_database';
} else {
  dbUrl = 'mongodb://localhost:27017/test_database';
}

app.get('/', (req, res) => {
  // Use the dbUrl based on the environment
  // ...
});

const PORT = process.env.PORT || 3000;

app.listen(PORT, () => {
  console.log(`Server is running on port ${PORT}`);
});
```

Another variation of this pattern is when different configuration files are used for different environments, such as `config.staging.json`, `config.dev.json`, and so on. This practice can lead to code duplication and maintenance challenges.

Consider the following directory structure:

```sh
- config
  - config.dev.json
  - config.staging.json
  - config.prod.json
- server.js
```

In this directory structure, there are separate configuration files for different environments.

The `config/config.dev.json` file:

```json
{
  "dbUrl": "mongodb://localhost:27017/dev_database",
  "apiBaseUrl": "http://localhost:3000/dev"
}
```

And here's what the `config/config.staging.json` file might look like:

```json
{
  "dbUrl": "mongodb://dbserver.staging:27017/staging_database",
  "apiBaseUrl": "http://localhost:3000/staging"
}
```

Then, a Node.js application might load it's environment-specific configuration data as follows, demonstrating this anti-pattern:

```js
const express = require('express');
const app = express();

const environment = process.env.NODE_ENV || 'development';
const config = require(`./config/config.${environment}.json`);

app.get('/', (req, res) => {
  // Use configuration values from the loaded config file
  const dbUrl = config.dbUrl;
  const apiBaseUrl = config.apiBaseUrl;

  // ...
});

const PORT = process.env.PORT || 3000;

app.listen(PORT, () => {
  console.log(`Server is running on port ${PORT}`);
});
```

In fact, even the official [dotenv package](https://github.com/motdotla/dotenv) mentions this anti pattern as part of the README:

> Should I have multiple .env files?
> No. We strongly recommend against having a "main" .env file and an "environment" .env file like .env.test. Your config should vary between deploys, and you should not be sharing values between environments.

